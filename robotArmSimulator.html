<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Test 1</title>
</head>
<body>
<canvas id="mainCanvas" width="400" height="400" style="border:1px solid #d3d3d3;">Your browser does not support the HTML5 canvas tag.</canvas>
<canvas id="hSpaceCanvas" width="400" height="400" style="border:1px solid #d3d3d3;">Your browser does not support the HTML5 canvas tag.</canvas>
<div id="detail"></div>
<div id="angels"></div>
<script>

var detail = document.getElementById("detail");
var angels = document.getElementById("angels");

var mainCanvas = document.getElementById("mainCanvas");
var hSpaceCanvas = document.getElementById("hSpaceCanvas");
var ctx_main = mainCanvas.getContext("2d");
var ctx_hspace = hSpaceCanvas.getContext("2d");

var obstacles = [
    {x:-190, y:-190, w:95, h:132},
    {x:40,   y:-151,   w:69, h:85},
    {x:-90,   y:60,   w:39, h:105},
];

var arm_1 = {
    len: 70,
    theta: 0,
    x: 0,
    y: 0,
    eef_x: 0,
    eef_y: 0,
};
var arm_2 = {
    len: 70,
    theta: 0,
    x: 0,
    y: 0,
    eef_x: 0,
    eef_y: 0,
};

var hspace_obstacle_map_resolution = 0.1;
let rrt_res = 4*hspace_obstacle_map_resolution;

var hspace_obstacle_map = [];
var rrt_graph = [];
var valid_random_point = [];
function create_hspace_obstacle_map() {
    for (var i = 0; i < 2*Math.PI; i += hspace_obstacle_map_resolution) {
        for (var j = 0; j < 2*Math.PI; j += hspace_obstacle_map_resolution) {
            let x1 = arm_1.x;
            let y1 = arm_1.y;
            let x2 = Math.cos(i) * arm_1.len + x1;
            let y2 = Math.sin(i) * arm_1.len + y1;
            let x3 = Math.cos(i + j + Math.PI) * arm_2.len + x2;
            let y3 = Math.sin(i + j + Math.PI) * arm_2.len + y2;

            if (!check_if_arm_okay({x: x1, y: y1, eef_x: x2, eef_y: y2}) ||
                !check_if_arm_okay({x: x2, y: y2, eef_x: x3, eef_y: y3}))
                hspace_obstacle_map.push({t1: i, t2: j});
            else
                valid_random_point.push({t1: i, t2: j});
        }
    }
}

function dist_to(p1, p2) {
    let dt1 = p1.t1 - p2.t1;
    let dt2 = p1.t2 - p2.t2;
    return Math.sqrt(dt1*dt1 + dt2*dt2);
}

function get_nearest_node_index(rnd_node) {
    var min_dist = null;
    var min_id = null;

    for (var i=0; i<rrt_graph.length; i++) {
        let d = dist_to(rrt_graph[i], rnd_node);
        if (min_dist == null || d < min_dist) {
            min_dist = d;
            min_id = i;
        }
    }
    return min_id;
}

function angle_to(p1, p2) {
    let dt1 = p2.t1 - p1.t1;
    let dt2 = p2.t2 - p1.t2;
    return Math.atan2(dt2, dt1);
}


function steer(parent_id, to_node, success_threshold) {
    let from_node = rrt_graph[parent_id];
    let extend_length = Math.min(dist_to(from_node, to_node), 0.5);
    let n_expand = Math.floor(extend_length / rrt_res);
    let theta = angle_to(from_node, to_node);

    var x = from_node.t1; var y = from_node.t2;
    for (var i=0; i<n_expand; i++) {
        x += rrt_res * Math.cos(theta);
        y += rrt_res * Math.sin(theta);
        let new_node = {
            t1: x, //from_node.t1 + Math.cos(theta) * rrt_res,
            t2: y, //from_node.t2 + Math.sin(theta) * rrt_res,
            parent_id: parent_id,
        };

        if (!rrt_check_colide(new_node))
            break;

        rrt_graph.push(new_node);
        if (calc_dist_to_goal(new_node) <= success_threshold) {
            return new_node;
        }
    }
    return null;
}

function rrt_check_colide(new_node) {
    for (var i=0; i<hspace_obstacle_map.length; i++) {
        let o = hspace_obstacle_map[i];
        if (dist_to(o, new_node) < rrt_res)
            return false;
    }
    return true;
}

function get_random_node() {
    if (Math.random() > 0.1)
        return valid_random_point[Math.floor(Math.random() * valid_random_point.length)];
    else  // goal point sampling
        return desired_conf;
}

function calc_dist_to_goal(p) {
    return dist_to(p, desired_conf);
}

function generate_final_course(goal_ind) {
    var path = [desired_conf];
    var node = rrt_graph[goal_ind];
    while (node.parent_id != -1) {
        path.unshift({t1:node.t1, t2:node.t2});
        node = rrt_graph[node.parent_id];
    }
    path.unshift({t1:node.t1, t2:node.t2});
    return path;
}

var interest_point = {x: null, y:null, t1: null, t2: null};
var desired_conf = {t1: 4, t2: 4};
var planned_path = [];
function run_path_planning() {
    planned_path = [];

    run_physics();
    create_hspace_obstacle_map();

    return run_path_planning_shot(rrt_res) ||
           run_path_planning_shot(rrt_res*5) ||
           run_path_planning_shot(rrt_res*10) ||
           run_path_planning_shot(rrt_res+5);
}

function run_path_planning_shot(success_threshold) {
    rrt_graph = [{t1: arm_1.theta, t2: arm_2.theta, parent_id: -1}];
    for (var i=0; i<500; i++) {
        let rnd_node = get_random_node();
        let nearest_node_index = get_nearest_node_index(rnd_node);
        let near_goal_node = steer(nearest_node_index, rnd_node, success_threshold);

        if (near_goal_node != null) {
            planned_path = generate_final_course(rrt_graph.length-1);
            return true;
        }
    }
    return false;
}


var current_desire = {t1: arm_1.theta, t2: arm_2.theta};
function apply_controller() {
    let max_step = 0.125;
    let precision_criteria = 0.1;

    if (Math.abs(arm_1.theta-current_desire.t1) < precision_criteria &&
        Math.abs(arm_2.theta-current_desire.t2) < precision_criteria) {
        // loading next path point
        if (planned_path.length > 0)
            current_desire = planned_path.shift();
        else
            return;
    }


    let dt1 = Math.abs(arm_1.theta - current_desire.t1);
    let dt2 = Math.abs(arm_2.theta - current_desire.t2);

    if (dt1 > dt2)
        ttl = dt1 / max_step;
    else
        ttl = dt2 / max_step;

    let step1 = dt1/ttl;
    let step2 = dt2/ttl;


    if (arm_1.theta < current_desire.t1 - precision_criteria)
        arm_1.theta += step1;
    else if (arm_1.theta > current_desire.t1 + precision_criteria)
        arm_1.theta -= step1;
    if (arm_2.theta < current_desire.t2 - precision_criteria)
        arm_2.theta += step2;
    else if (arm_2.theta > current_desire.t2 + precision_criteria)
        arm_2.theta -= step2;
}

function run_physics() {
    apply_controller();

    // calc arm1 end-effector
    arm_1.eef_x = Math.cos(arm_1.theta) * arm_1.len + arm_1.x;
    arm_1.eef_y = Math.sin(arm_1.theta) * arm_1.len + arm_1.y;

    // move to arms2
    arm_2.x = arm_1.eef_x;
    arm_2.y = arm_1.eef_y;

    // calc arm2 end-effector
    arm_2.eef_x = Math.cos(arm_2.theta + arm_1.theta + Math.PI) * arm_2.len + arm_2.x;
    arm_2.eef_y = Math.sin(arm_2.theta + arm_1.theta + Math.PI) * arm_2.len + arm_2.y;

    detail.innerHTML = "robot running";
    angels.innerText = "Thetas: (" + arm_1.theta.toFixed(2) + ", " + arm_2.theta.toFixed(2) + ")End Point Position: " +
        arm_1.eef_x.toFixed(2) + ", " + arm_1.eef_y.toFixed(2);
}

function check_if_arm_okay(arm) {
    for (var i=0; i<obstacles.length; i++) {
        let o = obstacles[i];
        if (is_segment_intersects(arm.x, arm.y, arm.eef_x, arm.eef_y, o.x, o.y, o.x+o.w, o.y))
            return false;
        if (is_segment_intersects(arm.x, arm.y, arm.eef_x, arm.eef_y, o.x, o.y, o.x, o.y+o.h))
            return false;
        if (is_segment_intersects(arm.x, arm.y, arm.eef_x, arm.eef_y, o.x+o.w, o.y+o.h, o.x+o.w, o.y))
            return false;
        if (is_segment_intersects(arm.x, arm.y, arm.eef_x, arm.eef_y, o.x+o.w, o.y+o.h, o.x, o.y+o.h))
            return false;
    }
    return true;
}

function collision_check() {
    return !check_if_arm_okay(arm_1) || !check_if_arm_okay(arm_2);
}


function reDraw() {
    // clear all
    ctx_main.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
    ctx_hspace.clearRect(0, 0, hSpaceCanvas.width, hSpaceCanvas.height);

    // draw main panel
    ctx_main.beginPath();
    ctx_main.fillStyle = '#eee';
    ctx_main.ellipse(200, 200, arm_1.len+arm_2.len, arm_1.len+arm_2.len, 360, 0, 360, false);
    ctx_main.fill();

    ctx_main.beginPath();
    ctx_main.strokeStyle = 'red';
    let eef_x = Math.cos(desired_conf.t1) * arm_1.len + arm_1.x;
    let eef_y = Math.sin(desired_conf.t1) * arm_1.len + arm_1.y;
    let eef_x2 = Math.cos(desired_conf.t1 + desired_conf.t2 + Math.PI) * arm_2.len + eef_x;
    let eef_y2 = Math.sin(desired_conf.t1 + desired_conf.t2 + Math.PI) * arm_2.len + eef_y;
    ctx_main.ellipse(eef_x2+200, eef_y2+200, 3, 3, 360, 0, 360, false);
    ctx_main.stroke();

    ctx_main.beginPath();
    ctx_main.strokeStyle = 'black';
    ctx_main.moveTo(200, 200);
    ctx_main.lineTo(arm_1.eef_x+200, arm_1.eef_y+200);
    ctx_main.lineTo(arm_2.eef_x+200, arm_2.eef_y+200);
    ctx_main.stroke();

    // draw h-space panel
    ctx_hspace.beginPath();
    ctx_hspace.strokeStyle = 'red';
    let thetas = {
        t1: 400 * (arm_1.theta - 0.07) / 6.0,
        t2: 400 * (arm_2.theta - 0.07) / 6.0
    };
    ctx_hspace.ellipse(thetas.t1, thetas.t2, 3, 3, 360, 0, 360, false);
    ctx_hspace.stroke();

    let thetasD = {
        t1: 400 * (desired_conf.t1 - 0.07) / 6.0,
        t2: 400 * (desired_conf.t2 - 0.07) / 6.0
    };
    ctx_hspace.beginPath();
    ctx_hspace.strokeStyle = 'black';
    ctx_hspace.ellipse(thetasD.t1, thetasD.t2, 5, 5, 360, 0, 360, false);
    ctx_hspace.stroke();

    // Draw Obstacles
    for (var i=0; i<obstacles.length; i++) {
        let o = obstacles[i];
        ctx_main.beginPath();
        ctx_main.fillStyle = 'gray';
        ctx_main.rect(o.x+200, o.y+200, o.w, o.h);
        ctx_main.fill();
    }


    let c_size = Math.ceil(hspace_obstacle_map_resolution * 20);
    ctx_hspace.strokeStyle = 'gray';
    for (var i=0; i<hspace_obstacle_map.length; i++) {
        let o = hspace_obstacle_map[i];
        ctx_hspace.beginPath();
        let t = {
            t1: 400 * (o.t1 - 0.07) / 6.0,
            t2: 400 * (o.t2 - 0.07) / 6.0
        };

        ctx_hspace.ellipse(t.t1, t.t2, c_size, c_size, 360, 0, 360, false);
        ctx_hspace.stroke();
    }

    // Draw Path
    ctx_hspace.beginPath();
    let t0 = {
            t1: 400 * (arm_1.theta - 0.07) / 6.0,
            t2: 400 * (arm_2.theta - 0.07) / 6.0
        };
    ctx_hspace.moveTo(t0.t1, t0.t2);
    let t = {
            t1: 400 * (current_desire.t1 - 0.07) / 6.0,
            t2: 400 * (current_desire.t2 - 0.07) / 6.0
        };
    ctx_hspace.ellipse(t.t1, t.t2, 3, 3, 360, 0, 360, false);
    for (var i=0; i<planned_path.length; i++) {
        let t = {
            t1: 400 * (planned_path[i].t1 - 0.07) / 6.0,
            t2: 400 * (planned_path[i].t2 - 0.07) / 6.0
        };
        ctx_hspace.strokeStyle = 'green';
        ctx_hspace.ellipse(t.t1, t.t2, 3, 3, 360, 0, 360, false);
    }
    ctx_hspace.stroke();

    // draw rest of path planning graph
    for (var i=0; i<rrt_graph.length; i++) {
        let t = {
            t1: 400 * (rrt_graph[i].t1 - 0.07) / 6.0,
            t2: 400 * (rrt_graph[i].t2 - 0.07) / 6.0
        };
        ctx_hspace.strokeStyle = 'orange';
        ctx_hspace.beginPath();
        ctx_hspace.ellipse(t.t1, t.t2, 3, 3, 360, 0, 360, false);

        let j = rrt_graph[i].parent_id;
        if (j >= 0) {
            let t2 = {
                t1: 400 * (rrt_graph[j].t1 - 0.07) / 6.0,
                t2: 400 * (rrt_graph[j].t2 - 0.07) / 6.0
            };
            ctx_hspace.lineTo(t2.t1, t2.t2);
        }
        ctx_hspace.stroke();
    }

    // draw intrest points
    ctx_hspace.beginPath();
    ctx_hspace.strokeStyle = 'green';
    t = {
        t1: 400 * (interest_point.t1 - 0.07) / 6.0,
        t2: 400 * (interest_point.t2 - 0.07) / 6.0
    };
    ctx_hspace.ellipse(t.t1, t.t2, 4, 4, 360, 0, 360, false);
    ctx_hspace.stroke();
    ctx_main.beginPath();
    ctx_main.strokeStyle = 'green';
    ctx_main.ellipse(interest_point.x+200, interest_point.y+200, 4, 4, 360, 0, 360, false);
    ctx_main.stroke();
}

function onCanvasClick(e) {
    e.stopPropagation();

    desired_conf = {
        t1: interest_point.t1,
        t2: interest_point.t2,
    };

    if (run_path_planning())
        console.log('find a path!');
    else
        console.log('no possible path found...');
}


function onMouseMoveMain(e) {
    e.stopPropagation();
    let cursor = {
        x: e.offsetX || e.originalEvent.layerX,
        y: e.offsetY || e.originalEvent.layerY
    };
    let x = cursor.x - 200;
    let y = cursor.y - 200;

    let dx = x*x + y*y;
    let dl = arm_1.len*arm_1.len + arm_2.len*arm_2.len;
    if (dx > dl)
        return;


    var q2 = Math.acos((dx - dl) / (2*arm_1.len*arm_2.len));

    var k1 = arm_1.len + arm_2.len * Math.cos(q2);
    var k2 = arm_2.len * Math.sin(q2);
    var q1 = Math.atan2(y, -x) - Math.atan2(k2, k1);


    interest_point.t1 = -(q1 - Math.PI);
    interest_point.t2 = -(q2 - Math.PI);
    interest_point.x = x;
    interest_point.y = y;
}

function onMouseMoveHSpc(e) {
    e.stopPropagation();
    let cursor = {
        x: e.offsetX || e.originalEvent.layerX,
        y: e.offsetY || e.originalEvent.layerY
    };

    interest_point.t1 = 6.0 * cursor.x / 400.0 + .07;
    interest_point.t2 = 6.0 * cursor.y / 400.0 + .07;

    let eef_x = Math.cos(interest_point.t1) * arm_1.len + arm_1.x;
    let eef_y = Math.sin(interest_point.t1) * arm_1.len + arm_1.y;
    let eef_x2 = Math.cos(interest_point.t1 + interest_point.t2 + Math.PI) * arm_2.len + eef_x;
    let eef_y2 = Math.sin(interest_point.t1 + interest_point.t2 + Math.PI) * arm_2.len + eef_y;

    interest_point.x = eef_x2;
    interest_point.y = eef_y2;

    //console.log(interest_point.x, interest_point.y, interest_point.t1, interest_point.t2);
}

function run() {
    run_physics();
    reDraw();

    if (planned_path.length)
        detail.innerHTML = "moving toward plan";
    else
        detail.innerHTML = "done!";

    if (!collision_check())
        setTimeout(run, 100);
    else {
        console.log('robot arm colided...');
        detail.innerHTML = "<span style=\"color: red;\"><b>robot arm colided...</b></span>";
    }
}

function ccw(ax, ay, bx, by, cx, cy) {
    return (bx - ax)*(cy - ay) - (by - ay)*(cx - ax);
}

function is_segment_intersects(ax, ay, bx, by, cx, cy, dx, dy) {
    return ccw(ax, ay, bx, by, cx, cy) * ccw(ax, ay, bx, by, dx, dy) < 0 &&
            ccw(cx, cy, dx, dy, ax, ay) * ccw(cx, cy, dx, dy, bx, by) < 0;
}


arm_1.theta = Math.random() + 0.01;
arm_2.theta = Math.random() + 0.01;

mainCanvas.addEventListener("mousemove", onMouseMoveMain, false);
hSpaceCanvas.addEventListener("mousemove", onMouseMoveHSpc, false);
mainCanvas.addEventListener("click", onCanvasClick, false);
hSpaceCanvas.addEventListener("click", onCanvasClick, false);

if (run_path_planning())
    console.log('find a path!');
else
    console.log('no possible path found...');
run();

</script>
</body>
</html>